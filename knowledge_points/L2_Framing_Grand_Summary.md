# 终极梳理：Layer 2 的五大成帧方法 (Framing Methods) 全景对比

在数据链路层，网卡的唯一目标就是**在绵延不绝的 0 和 1 的物理层信号中，准确找出“一帧”从哪里开始，到哪里结束 (Frame boundary detection)**。

为了达成这个目的，人类历史上发明了五种各显神通的方法。你提到的 4B5B、Bit-stuffing、Length Specification 全部属于解决这个问题的不同流派！下面是它们最清晰的分类与考点对比：

---

## 1. 简单粗暴派：Length Specification of Payload (长度指示法)

**📍 核心原理**：
废话不多说，我直接在帧的最开头（Header里）写明：“这包数据有 `1500` 个字节”。
接收方只要看到这个数字，就开始傻瓜式地往后盲数 `1500` 个字节。数完之后，直接切断，这就是完整的一帧。

**💥 致命弱点 (考点)**：
- **错位灾难**：如果在传输过程中，因为物理干扰导致这个表示“长度”的数字出错了（比如 `1500` 变成了 `9900`），接收方就会一直死等 9900 个字节，导致后面的所有帧全部粘连崩溃，永远无法重新同步对齐。

---

## 2. 经典打补丁派：基于控制标记的成帧 (Sentinel / Flags)
由于“长度指示”容易出错导致后续永远错位，大家决定用**特殊的标记符 (Flag)** 来直接标定开始和结束。但这会带来 **代码透明性危机 (Code Transparency, 怕被普通数据撞车冒充)**。由此分化出两种著名的打补丁技术：

### 2a. Byte-Oriented: 字符/字节填充 (Byte-stuffing / Character-stuffing)
**📍 核心原理**：
使用特殊的 ASCII 码作为边界，比如 `STX` (开始) 和 `ETX` (结束)。
为了防止 Payload 里的图像数据恰好有某个字节和 `ETX` 一模一样，需要用到 **`ESC` (转义字符)** 进行打补丁防守。
- 如果数据里有 `ETX`，发送方塞入变成 `ESC ETX`。
- 接收方看到 `ESC`，把它删掉，保留后面的原数据。

### 2b. Bit-Oriented: 比特填充 (Bit-stuffing) -> 【考试霸屏王者】
**📍 核心原理 (以 HDLC 协议为例)**：
不使用字符了，直接规定 `01111110` 作为一帧的开始和结束标记。
**防撞车手段 (考点采分点)**：发送方只要看到数据里连续出现了 **5个1**，立刻在屁股后面强行插入一个 **`0`**。这样全天下正常的 Payload 里绝对凑不出 6个1的结束标记。接收方看到 `111110` 则删掉 0。
**🎯 必背考点**：*What is the purpose of bit-stuffing? -> Prevention of control characters (frame delimiters) in the payload.*

---

## 3. 降维打击派：4B5B Encoding (留白式成帧)

**📍 核心原理**：
我不用 `ESC` 来打补丁，我也不傻乎乎地去数连续的 1 来塞另外的 0。我直接**从源头上物理消灭这种冲突**。
4比特的数据映射为 5比特在线缆上传输。5比特有 32 种组合，但我们只挑 16 种用来表示数据。
剩下的 16 种空余组合中，我们挑出几个作为**绝对专属的控制字符 (Control Characters, 比如 `J/K` 和 `T`)**。

**🌟 它是怎么解决透明性危机的？**
用户的数据永远只能被映射成那 16 种正常组合，**绝对、永远不可能**被映射成控制字符专用的那几种组合！所以网卡只要在线缆上看到了控制字符的波形，它 100% 放心这绝对是帧边界，不需要任何补丁操作。
（当然，4B5B 的另一个大考点是：保证信号跳变以实现**时钟恢复 Clock recovery**）。

---

## 4. 物理层魔法派：Code Rule Violation (编码违例)

**📍 核心原理 (以 Manchester 曼彻斯特编码为例)**：
最底层的物理波形也是有规则的（比如曼彻斯特规定，在一个时钟周期中间**必须**发生电平翻转）。
只要发送方故意发一段“没有翻转的、违法的”物理波形！
正常数据绝对不可能产生这种非法波形。接收方只要检测到电压违法了，立刻知道：“好的，这是一帧的开始或结束信号”。

---

## 🎯 总结与考试指南 (How to distinguish in exams)

当你看到题目问到以下关键字时，秒切对应考点：
1. 看到 **"Prevention of control characters in payload"** 👉 填 **Bit-stuffing** 或者说它的目的就是解构代码透明性危机。
2. 看到 **"Clock recovery"** 或 **"Control characters"** 的双重优势 👉 填 **4B5B Encoding**。
3. 如果问你为什么 4B5B 里面没问题？ 👉 你回答：因为 4B5B 为控制字符预留了独立的 5-bit Code words，普通数据无法映射成它们。
4. 如果问你 **"Length specification"** 的前提是什么？ 👉 你回答：前提是长度字段绝对不能出错（必须 correct），否则所有后续同步都会崩溃。
