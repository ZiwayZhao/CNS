# 知识点精讲：数据链路层的成帧与填充机制 (Framing, Bit & Byte Stuffing) 🧱

在 Layer 2 数据链路层中，除了之前讲的 Ethernet (以太网) 这样有着固定长度 Preamble/Type 的帧结构外，还有一类**面向位 (Bit-oriented) 或面向字节 (Byte-oriented)** 的点对点协议（如 **HDLC** 和 **PPP**）。

它们的核心问题是：**如何在连绵不断的数据流中，告诉接收方“哪里是一帧的开始，哪里是结束”？**

这类协议通常使用一个特殊的**标志序列 (Flag)** 来作为帧的分界线。
- 对于 HDLC，Flag 是预定义的比特模式：**`01111110`**
- 对于 PPP，Flag 是预定义的字节：**`0x7E`** (本质同上)

> **⚠️ 致命问题 (The Problem)**：如果用户发送的真实有效载荷 (Payload) 中，**恰好也包含了和 Flag 完全一样的比特或字节组合**，接收方就会误以为这一帧已经提前结束了！
> **✅ 解决方案**：**填充 (Stuffing)**。发送端在里面塞入一些假信号来破坏这个组合，接收端收到后再把假信号剔除还原。

这部分知识点的考法极其固定，基本上就是：**给一串数据让你模拟发送方的填充，模拟接收方的剔除，以及计算最大开销 (Overhead)**。

---

## 一、 比特填充 (Bit Stuffing) - 面向 HDLC

**核心规则：见 5 插 0**

### 1. 发送方逻辑 (Transmitter) - 【常见计算题 / 填空题】
发送方在发送 Payload 时，逐位扫描。如果它连续看到了 **5 个 `1`**，无论是遇到了真正的 Flag 还是碰巧用户的 payload 就是一堆 1，它都会**无脑地在第 5 个 `1` 后面强行插入一个 `0`**。

- **考场演练**：
  - **原始 Payload**: `0110 11111 1100 11111 0`
  - **发送端发出** (加粗部分为 Stuffing): `0110 11111`**`0`**`1100 11111`**`0`**`0`
  - *注意：哪怕第 5 个 `1` 后面的原始位本来就是 `0` (会变成 `0111110`)，发送方依然会无脑插入一个 `0`。它绝不可能去碰运气！*

### 2. 接收方逻辑 (Receiver) - 【反向解码题】
接收方在收到数据流时，时刻监视着流进来的比特：如果它连续看到了 **5 个 `1`**，它会立即检查紧随其后的下一位 (第 6 位)：
1. **如果第 6 位是 `0`**：这说明它是发送方强行塞进来的！接收方立刻**将这个 `0` 丢弃/剥离 (Destuff)**，剩下的数据交给上层。
2. **如果第 6 位是 `1`** (此时已经连续 6 个 `1` 了)：它继续看第 7 位：
   - 如果第 7 位是 `0` (即 `01111110`)：完美！这是一个合法的 **End-of-Frame Flag (帧结束标志)**。
   - 如果第 7 位还是 `1` (即遇到了连续的 7 个或更多 `1`)：这是一个非法的状态，表明链路出现了错误，或者发送方主动发出了 **Abort (中止)** 信号，扔掉这个帧！

### 3. 【极高频考点】最大开销计算 (Worst-case Overhead)
- **题目**: "What is the maximum overhead introduced by bit stuffing?" (比特填充造成的最大开销比例是多少？)
- **解答**: 当用户的 Payload 全部都是恶意的连续的 `1` 时 (即 `111111111...`)，发送方每逢 5 个 `1` 就要插入 1 个 `0`。
- **结论**: 最大开销是 $\frac{1}{5} = 20\%$。

---

## 二、 字节填充 / 字符填充 (Byte/Character Stuffing) - 面向 PPP

在面向字节的协议 (PPP) 中，我们不再逐位扫描，而是以 **8 bits (1 Byte)** 为单位进行扫描。

- 结束标志字符 (Flag Byte): **`0x7E`** (`0111 1110`)
- 转义控制字符 (Escape Byte/ESC): **`0x7D`** (`0111 1101`)

**核心规则：见鬼变脸 (转义)**

### 1. 发送方逻辑 (Transmitter)
发送方逐字节扫描 Payload：
- **场景 A**：如果 Payload 里混入了一个真实数据的 `0x7E` (与 Flag 撞脸)。
  发送方会把它替换成两个字节的组合：先塞入一个 **`ESC (0x7D)`**，然后紧接着把原来的 `0x7E` 的第 6 个比特翻转 (即 `XOR 0x20`) 变成 **`0x5E`**。
  👉 `0x7E` $\xrightarrow{\text{替换为}}$ `0x7D 0x5E`
- **场景 B**：如果 Payload 里刚好有个数据是 `0x7D` (与 ESC 密码本撞脸)。
  那也得办它！先塞入一个 **`ESC (0x7D)`**，然后把这个假的 `0x7D` 也翻转变成 **`0x5D`**。
  👉 `0x7D` $\xrightarrow{\text{替换为}}$ `0x7D 0x5D`

> **考前备注**：*各个协议翻转的规则 (XOR 0x20) 可能略有不同，但考查宗旨都是 `FLAG -> ESC + (Modified FLAG)` 以及 `ESC -> ESC + (Modified ESC)`。*

### 2. 接收方逻辑 (Receiver)
接收方大口吃字节。如果吃到了 `0x7E`，那就是帧结束了。如果吃到了 `0x7D`：
- 它知道这绝不是真数据，而是提醒它“下一个字节被施了魔法”。
- 它直接**扔掉**这个 `0x7D (ESC)`。
- 把下一个字节 (比如 `0x5E`) 捡起来，逆向翻转第 6 个比特 (再 `XOR 0x20`) 还原成真实的 `0x7E`，并当成真数据放进载荷里。

### 3. 【极高频考点】最大开销计算 (Worst-case Overhead)
- **题目**: "What is the maximum overhead introduced by byte stuffing?" (字节填充造成的最大开销比例是多少？)
- **解答**: 如果用户传的电影文件里，满屏巧合地全都是 `0x7E` 或全都是 `0x7D`！
- **后果**: 发送方每遇到一个原本只有 1 字节的数据，都会悲催地把它扩充成 2 个字节：`0x7E -> 0x7D 0x5E`。
- **结论**: 数据量直接翻倍！**最大开销是 $100\%$**。

---

## 三、 总结：考场防坑指南 🛡️

1. **遇到 Bit Stuffing (比特填充) 时**，记得它是**见 5 杀 1**，绝不看第 6 位是什么。如果你做模拟题发现自己犹豫“后面已经是 0 了我不插了吧？”，打住，**必须插！硬件是没有智商的，数到 5 就必须插 0！**
2. **遇到 Byte Stuffing (字节填充) 时**，重点记住它不仅要转义 FLAG 标志位，**转义字符 ESC 自身也要被转义**。
3. **Overhead (开销) 是最爱考的简略题**：记住 `Bit Stuffing 的最差开销是 20%`，而 `Byte Stuffing 的最差开销是 100%`。
