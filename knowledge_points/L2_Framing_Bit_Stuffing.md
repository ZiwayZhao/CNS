# 知识点复习：L2 成帧与位填充 (Framing & Bit-Stuffing)

## 📌 考频分析 (Testing Frequency)
- **考频评级**：**常考题 (Medium-High Frequency)**
- **复习建议**：**主要出现在 Quiz 填空/选择题，或者期末简答题中。考法极其固定，只需要背诵两句话的核心定义和操作原理。**
- **试卷覆盖情况**：
  - Quiz2 2021: 简答问 Bit-stuffing 是什么。
  - Endterm 2019: 简答问 Bit-stuffing 的目的是什么。

---

## 📚 考点 1：为什么需要成帧 (Framing)？

在物理层，数据是一串连绵不断、没有尽头的 `0` 和 `1` 的电信号瀑布。
到了数据链路层 (Layer 2)，网卡必须在这个瀑布中精确地切西瓜，找到哪里是**一帧的开始 (Start)**，哪里是**一帧的结束 (End)**。即：**Frame boundary detection (帧边界检测)**。

寻找边界的初级手段：
**使用特定的标记序列 (Sentinel / Flag)**，例如定死 `01111110` 作为这一帧的结束。

---

## 💥 考点 2：致命漏洞与 Bit-stuffing (位填充技术的目的)

使用固定标记来切分帧会面临一个**致命问题**：**代码透明性危机 (Code Transparency Issue)**。
如果在用户正常发送的纯数据 (Payload) 里（比如随便一张自拍照片的二进制码中），偶然出现了连续的 `01111110` 怎么办？接收方的网卡会误以为这已经是帧的结尾了，直接提前一刀切断，导致数据永久性损坏！

为了解决这个问题，发明了 **位填充 (Bit-stuffing)**。

**Question (必背简答):** What is the purpose of bit stuffing / What is meant by bit stuffing?
**Answer (标准答案采分点):**
**Prevention of the occurrence of control characters (or frame delimiters) in the payload.**
*(中文翻译：通过故意向有效载荷中插入额外的比特，来防止有效载荷中意外出现控制字符/边界标记。)*
📍 **出处 (Source):** *[endterm_2019-solution_en.md; quiz2_2021-solution_en.md]*

---

## 🎭 考点 3：什么是 Control Characters (控制字符) 与 Byte-stuffing？

在考卷的标准答案中，反复提到了 "Control characters" (控制字符)。它到底是什么？
这里其实涉及到了另一种经典成帧方案：**基于字符/字节的成帧 (Byte-Oriented Framing)**。

1. **常见的控制字符有哪些？**
   在早期的 ASCII 通信中，人们为了框出一段数据，专门保留了几个绝对不用于显示文本的**底层控制密码 (Control Characters)**：
   - **`STX` (Start of Text)**: 用于标志一帧的**开始**。
   - **`ETX` (End of Text)**: 用于标志一帧的**结束**。
   - **`ESC` (Escape / 转义)**: 用于化解透明性危机的神奇字符。

2. **致命错误发生的场景：**
   发送方发了一个数据包，格式为 `[STX] + 数据部分 + [ETX]`。
   好巧不巧，用户正在传输的一个二进制文件（比如一首歌）里，某一个字节的二进制流恰好和 `ETX` 一模一样！
   接收方读到一半，突然读到了这个夹杂在歌曲数据里的假 `ETX`，系统大喊一声：“本帧结束！”直接把这首歌后面所有的真实数据腰斩丢弃。

3. **魔法解法：Byte-stuffing (字节填充) 与 ESC 转义**
   像极了编程语言里字符串中打印双引号要加反斜杠 `\"` 一样，这里的救星是 `ESC` 控制字符。
   - **规则 A**：如果发送方发现你的 Payload 数据里恰好混入了一个 `ETX`，他就会在这个假的 `ETX` 前面，**强行塞入一个 `ESC`** (变成 `ESC ETX`)。接受方看到 `ESC` 就秒懂：“哦，后面那个 `ETX` 是个普通人，不是关机大招！”并且把 `ESC` 剔除。
   - **规则 B**：如果用户的 Payload 里本来就混入了一个 `ESC` 怎么办？发送方会在它前面**再垫一个 `ESC`** (变成 `ESC ESC`)。接收方看到连续两个，剔除第一个，留下第二个当成普通数据。

*(提示：虽然考卷极度长情于考 Bit-stuffing 比特填充，但写答案时用 prevention of control characters 囊括了比特位边界标记和字节级控制字符的所有情况。)*

---

## 🧮 考点 3：Bit-stuffing 的硬核操作原理 (以 HDLC 协议为例)

HDLC (High Level Data Link Control) 是最经典的使用位填充的协议。它的起始和结束标记 (Flag) 规定为 `01111110`（即两头是0，中间连续 6 个 1）。

**发送方的“塞入”操作 (Sender stuffing):**
为了绝对确保用户的 Payload 数据里永远不会出现连续的 6 个 `1`。发送方在灌入数据时时刻监视，只要发现连续输出了 **5 个 `1`**，就会强行在屁股后面**免费送一个 `0`**（填充位）。
- **Input (用户本来想发)**: `110010 11111 1 0111111`
- **Output (实际在线缆上走)**: `110010 11111` **`0`** `1 011111` **`0`** `1`

**接收方的“剔除”操作 (Receiver destuffing):**
接收方只要看到**连续的 5 个 `1` 后面跟着一个 `0`**，就会立刻明白：“哦，这是对面怕我误会切断，故意凑数塞进来的”。接收方会直接**把这个 `0` 删掉 (removes the 0 bit)**，从而神不知鬼不觉地还原出最原始的数据。

**极限防守：** 如果接收方真的看到了连续的 6 个 `1`（`01111110`），那这绝对不是数据，这就是真正的控制标记，标志着本帧结束！

---

## 🛡️ 考点 4：成帧的备用方案 —— 编码规则违例 (Code rule violation)

除了塞假比特这种暴力手法，怎么区分普通数据和“开始/结束”控制信号？
在物理层学过 **Manchester 曼彻斯特编码**（必须在周期中间翻转跳变以携带时钟）。

有一种极其天才的成帧方法：**故意在传输开头/结尾发一段“违反曼彻斯特跳变规则”的错误波形。**
由于这个波形是违法的，正常的数据里绝对不可能产生这种波形。接收方一看到这种破绽，立刻秒懂：“哦，这不是假数据，这是帧开始/结束的超级控制令箭！”
📍 **出处 (Source):** *[slides_chap2.pdf, Page 51]*
